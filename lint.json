[{"filePath":"C:\\Users\\riote\\WorkSpace\\shadow_dex\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\riote\\WorkSpace\\shadow_dex\\src\\App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\riote\\WorkSpace\\shadow_dex\\src\\components\\DynamicIcon.tsx","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":10,"column":5,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":10,"endColumn":84,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[285,364],"text":"// @ts-expect-error - Lucide icons exist on the module but TS doesn't know exact keys"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport * as LucideIcons from 'lucide-react';\r\nimport { HelpCircle } from 'lucide-react';\r\n\r\ninterface DynamicIconProps extends LucideIcons.LucideProps {\r\n    name: string;\r\n}\r\n\r\nconst DynamicIcon: React.FC<DynamicIconProps> = ({ name, ...props }) => {\r\n    // @ts-ignore - Lucide icons exist on the module but TS doesn't know exact keys\r\n    const Icon = LucideIcons[name] || HelpCircle;\r\n\r\n    return <Icon {...props} />;\r\n};\r\n\r\nexport default DynamicIcon;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\riote\\WorkSpace\\shadow_dex\\src\\components\\EntryEditor.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'categories' logical expression could make the dependencies of useEffect Hook (at line 34) change on every render. To fix this, wrap the initialization of 'categories' in its own useMemo() Hook.","line":18,"column":11,"nodeType":"VariableDeclarator","endLine":18,"endColumn":73},{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nC:\\Users\\riote\\WorkSpace\\shadow_dex\\src\\components\\EntryEditor.tsx:31:13\n  29 |     useEffect(() => {\n  30 |         if (!entryId && categories.length > 0 && !category) {\n> 31 |             setCategory(categories[0].name);\n     |             ^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  32 |             setIsLoaded(true);\n  33 |         }\n  34 |     }, [categories, entryId, category]);","line":31,"column":13,"nodeType":null,"endLine":31,"endColumn":24}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\r\nimport { X, Save, Trash2, User, FileText, Edit, Eye } from 'lucide-react';\r\nimport styles from './EntryEditor.module.css';\r\nimport { db } from '../db/db';\r\nimport { useLiveQuery } from 'dexie-react-hooks';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { useCreateBlockNote, SuggestionMenuController, LinkToolbarController } from '@blocknote/react';\r\nimport { BlockNoteView } from '@blocknote/mantine';\r\nimport { SuggestionMenu } from '@blocknote/core/extensions';\r\nimport '@blocknote/mantine/style.css';\r\n\r\ninterface EntryEditorProps {\r\n    entryId?: string | null;\r\n    onClose: () => void;\r\n}\r\n\r\nconst EntryEditor: React.FC<EntryEditorProps> = ({ entryId, onClose }) => {\r\n    const categories = useLiveQuery(() => db.categories.toArray()) || [];\r\n    const [title, setTitle] = useState('');\r\n    const [category, setCategory] = useState('');\r\n    const [tagsStr, setTagsStr] = useState('');\r\n    const [content, setContent] = useState('');\r\n\r\n    const [isEditing, setIsEditing] = useState(!entryId);\r\n\r\n    const [initialContent, setInitialContent] = useState('');\r\n    const [isLoaded, setIsLoaded] = useState(false);\r\n\r\n    useEffect(() => {\r\n        if (!entryId && categories.length > 0 && !category) {\r\n            setCategory(categories[0].name);\r\n            setIsLoaded(true);\r\n        }\r\n    }, [categories, entryId, category]);\r\n\r\n    useEffect(() => {\r\n        if (entryId) {\r\n            db.entries.get(entryId).then(entry => {\r\n                if (entry) {\r\n                    setTitle(entry.title);\r\n                    setCategory(entry.category);\r\n                    setTagsStr(entry.tags.join(', '));\r\n                    setContent(entry.content);\r\n                    setInitialContent(entry.content);\r\n                }\r\n                setIsLoaded(true);\r\n            });\r\n        }\r\n    }, [entryId]);\r\n\r\n    // Create the editor instance. We wait for `isLoaded` to ensure we have the correct \r\n    // initialContent before instantiating, to avoid empty editors on edit.\r\n    const editor = useCreateBlockNote({\r\n        initialContent: isLoaded && initialContent ? undefined : undefined,\r\n    });\r\n\r\n    // Since initialContent must be set asynchronously when editing, we load it into the editor once it's ready\r\n    useEffect(() => {\r\n        async function loadMarkdown() {\r\n            if (isLoaded && editor) {\r\n                if (initialContent) {\r\n                    const blocks = await editor.tryParseMarkdownToBlocks(initialContent);\r\n                    editor.replaceBlocks(editor.document, blocks);\r\n                }\r\n            }\r\n        }\r\n        loadMarkdown();\r\n    }, [isLoaded, initialContent, editor]);\r\n\r\n    const handleSave = async () => {\r\n        if (!title.trim()) return;\r\n\r\n        const tags = tagsStr.split(',').map(t => t.trim()).filter(t => t);\r\n        const now = Date.now();\r\n\r\n        if (entryId) {\r\n            await db.entries.update(entryId, {\r\n                title, category, tags, content, updatedAt: now\r\n            });\r\n        } else {\r\n            await db.entries.add({\r\n                id: uuidv4(),\r\n                title,\r\n                category,\r\n                tags,\r\n                content,\r\n                createdAt: now,\r\n                updatedAt: now\r\n            });\r\n        }\r\n        onClose();\r\n    };\r\n\r\n\r\n\r\n    const handleDelete = async () => {\r\n        if (entryId) {\r\n            if (window.confirm('本当に削除しますか？')) {\r\n                await db.entries.delete(entryId);\r\n                onClose();\r\n            }\r\n        }\r\n    };\r\n\r\n    return (\r\n        <div className={styles.overlay}>\r\n            <div className={styles.modal}>\r\n                <div className={styles.header}>\r\n                    <div className={styles.actions}>\r\n                        {entryId && (\r\n                            <button onClick={() => setIsEditing(!isEditing)} className={styles.iconBtn} title={isEditing ? \"閲覧モードにする\" : \"編集モードにする\"}>\r\n                                {isEditing ? <Eye size={18} /> : <Edit size={18} />}\r\n                            </button>\r\n                        )}\r\n                        {entryId && (\r\n                            <button onClick={handleDelete} className={`${styles.iconBtn} ${styles.danger}`} title=\"削除\">\r\n                                <Trash2 size={18} />\r\n                            </button>\r\n                        )}\r\n                        <button onClick={onClose} className={styles.iconBtn} title=\"閉じる\">\r\n                            <X size={20} />\r\n                        </button>\r\n                    </div>\r\n                </div>\r\n\r\n                <div className={styles.body}>\r\n                    {isEditing ? (\r\n                        <input\r\n                            type=\"text\"\r\n                            className={styles.titleInput}\r\n                            placeholder=\"タイトル（無題）\"\r\n                            value={title}\r\n                            onChange={e => setTitle(e.target.value)}\r\n                            autoFocus\r\n                        />\r\n                    ) : (\r\n                        <div className={styles.viewTitle}>{title || '無題'}</div>\r\n                    )}\r\n\r\n                    <div className={styles.metaRow}>\r\n                        <div className={styles.metaLabel}>カテゴリ</div>\r\n                        {isEditing ? (\r\n                            <select\r\n                                className={styles.select}\r\n                                value={category}\r\n                                onChange={e => setCategory(e.target.value)}\r\n                            >\r\n                                {categories.map(cat => (\r\n                                    <option key={cat.id} value={cat.name}>{cat.name}</option>\r\n                                ))}\r\n                            </select>\r\n                        ) : (\r\n                            <div className={styles.viewText}>{category}</div>\r\n                        )}\r\n                    </div>\r\n\r\n                    <div className={styles.metaRow}>\r\n                        <div className={styles.metaLabel}>タグ</div>\r\n                        {isEditing ? (\r\n                            <input\r\n                                type=\"text\"\r\n                                className={styles.tagInput}\r\n                                placeholder=\"カンマ区切りで入力 (例: 営業部, 要注意)\"\r\n                                value={tagsStr}\r\n                                onChange={e => setTagsStr(e.target.value)}\r\n                            />\r\n                        ) : (\r\n                            <div className={styles.viewText}>{tagsStr || 'なし'}</div>\r\n                        )}\r\n                    </div>\r\n\r\n                    <div\r\n                        className={`${styles.editorContainer} ${isEditing ? styles.editingMode : ''}`}\r\n                        onClick={(e) => {\r\n                            const target = e.target as HTMLElement;\r\n                            const anchor = target.closest('a');\r\n\r\n                            if (isEditing) {\r\n                                // 編集モード時はリンク遷移（新規タブ等の挙動）を完全にブロックする\r\n                                if (anchor) {\r\n                                    e.preventDefault();\r\n                                    e.stopPropagation();\r\n                                }\r\n                                return;\r\n                            }\r\n\r\n                            if (!isEditing) {\r\n                                if (anchor) {\r\n                                    const href = anchor.getAttribute('href');\r\n                                    if (href && href.startsWith('/entry/')) {\r\n                                        e.preventDefault();\r\n                                        e.stopPropagation();\r\n                                        const id = href.replace('/entry/', '');\r\n                                        window.dispatchEvent(new CustomEvent('open-entry', { detail: { id } }));\r\n                                    }\r\n                                }\r\n                            }\r\n                        }}\r\n                    >\r\n                        {isLoaded && editor && (\r\n                            <BlockNoteView\r\n                                editor={editor}\r\n                                theme=\"light\" /* will be overridden by CSS variables if needed */\r\n                                editable={isEditing}\r\n                                onChange={async () => {\r\n                                    const markdown = await editor.blocksToMarkdownLossy(editor.document);\r\n                                    setContent(markdown);\r\n                                }}\r\n                            >\r\n                                <SuggestionMenuController\r\n                                    triggerCharacter={\"@\"}\r\n                                    getItems={async (query) => {\r\n                                        const entries = await db.entries.toArray();\r\n                                        return entries\r\n                                            .filter(e => e.title.toLowerCase().includes(query.toLowerCase()))\r\n                                            .map(entry => ({\r\n                                                title: entry.title,\r\n                                                onItemClick: () => {\r\n                                                    editor.getExtension(SuggestionMenu)?.clearQuery();\r\n                                                    editor.insertInlineContent([\r\n                                                        {\r\n                                                            type: \"link\",\r\n                                                            href: `/entry/${entry.id}`,\r\n                                                            content: `@${entry.title}`\r\n                                                        },\r\n                                                        {\r\n                                                            type: \"text\",\r\n                                                            text: \" \",\r\n                                                            styles: {}\r\n                                                        }\r\n                                                    ]);\r\n                                                },\r\n                                                subtext: entry.category,\r\n                                                icon: entry.category === '人物メモ' ? <User size={18} /> : <FileText size={18} />\r\n                                            }));\r\n                                    }}\r\n                                />\r\n                                <SuggestionMenuController\r\n                                    triggerCharacter={\"[\"}\r\n                                    getItems={async (query) => {\r\n                                        const cleanQuery = query.startsWith('[') ? query.slice(1) : query;\r\n                                        const entries = await db.entries.toArray();\r\n                                        return entries\r\n                                            .filter(e => e.title.toLowerCase().includes(cleanQuery.toLowerCase()))\r\n                                            .map(entry => ({\r\n                                                title: entry.title,\r\n                                                onItemClick: () => {\r\n                                                    // By default, SuggestionMenu only removes the query and its trigger `[`\r\n                                                    // We typed `[[` so we have to manually delete an extra `[` backwards before replacing\r\n                                                    editor.getExtension(SuggestionMenu)?.clearQuery();\r\n                                                    const pos = editor._tiptapEditor.state.selection.from;\r\n                                                    editor._tiptapEditor.commands.deleteRange({ from: pos - 1, to: pos });\r\n\r\n                                                    editor.insertInlineContent([\r\n                                                        {\r\n                                                            type: \"link\",\r\n                                                            href: `/entry/${entry.id}`,\r\n                                                            content: `[[${entry.title}]]`\r\n                                                        },\r\n                                                        {\r\n                                                            type: \"text\",\r\n                                                            text: \" \",\r\n                                                            styles: {}\r\n                                                        }\r\n                                                    ]);\r\n                                                },\r\n                                                subtext: entry.category,\r\n                                                icon: <FileText size={18} />\r\n                                            }));\r\n                                    }}\r\n                                />\r\n                                <LinkToolbarController\r\n                                    linkToolbar={(props) => {\r\n                                        // If it's an internal link, intercept it here instead of showing the toolbar\r\n                                        if (props.url.startsWith('/entry/')) {\r\n                                            // Provide a simple button to navigate when NOT editing\r\n                                            if (isEditing) return null;\r\n\r\n                                            const id = props.url.replace('/entry/', '');\r\n                                            return (\r\n                                                <div className=\"blocknote-custom-link-toolbar\" style={{\r\n                                                    padding: '8px',\r\n                                                    backgroundColor: 'white',\r\n                                                    borderRadius: '8px',\r\n                                                    boxShadow: '0 4px 6px rgba(0,0,0,0.1)',\r\n                                                    display: 'flex',\r\n                                                    gap: '8px',\r\n                                                    alignItems: 'center'\r\n                                                }}>\r\n                                                    <span style={{ fontSize: '14px', fontWeight: 500, color: '#4F46E5' }}>{props.text}</span>\r\n                                                    <button\r\n                                                        onClick={() => {\r\n                                                            const event = new CustomEvent('open-entry', { detail: { id } });\r\n                                                            window.dispatchEvent(event);\r\n                                                            if (props.setToolbarOpen) {\r\n                                                                props.setToolbarOpen(false);\r\n                                                            }\r\n                                                        }}\r\n                                                        style={{\r\n                                                            padding: '4px 8px',\r\n                                                            backgroundColor: '#4F46E5',\r\n                                                            color: 'white',\r\n                                                            border: 'none',\r\n                                                            borderRadius: '4px',\r\n                                                            cursor: 'pointer',\r\n                                                            fontSize: '12px'\r\n                                                        }}\r\n                                                    >\r\n                                                        開く\r\n                                                    </button>\r\n                                                </div>\r\n                                            );\r\n                                        }\r\n\r\n                                        // For external links, just render nothing or a custom fallback if we wanted to\r\n                                        // By returning undefined or a default, it usually bypasses, but since we replaced it,\r\n                                        // we should probably just show a basic \"open\" link for standard URLs.\r\n                                        return (\r\n                                            <div style={{ padding: '4px', backgroundColor: 'white', borderRadius: '4px', boxShadow: '0 2px 4px rgba(0,0,0,0.1)' }}>\r\n                                                <a href={props.url} target=\"_blank\" rel=\"noreferrer\" style={{ fontSize: '14px', color: 'blue', textDecoration: 'none' }}>開く</a>\r\n                                            </div>\r\n                                        );\r\n                                    }}\r\n                                />\r\n                            </BlockNoteView>\r\n                        )}\r\n                    </div>\r\n                </div>\r\n\r\n                <div className={styles.footer}>\r\n                    {isEditing ? (\r\n                        <button onClick={handleSave} className={styles.primaryBtn}>\r\n                            <Save size={16} />\r\n                            <span>保存</span>\r\n                        </button>\r\n                    ) : (\r\n                        <div style={{ flex: 1 }}></div>\r\n                    )}\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default EntryEditor;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\riote\\WorkSpace\\shadow_dex\\src\\components\\EntryList.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'entries' logical expression could make the dependencies of useMemo Hook (at line 52) change on every render. Move it inside the useMemo callback. Alternatively, wrap the initialization of 'entries' in its own useMemo() Hook.","line":26,"column":11,"nodeType":"VariableDeclarator","endLine":34,"endColumn":12}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo } from 'react';\r\nimport styles from './EntryList.module.css';\r\nimport { useLiveQuery } from 'dexie-react-hooks';\r\nimport { db } from '../db/db';\r\nimport { format } from 'date-fns';\r\nimport { FileText } from 'lucide-react';\r\n\r\ninterface EntryListProps {\r\n    searchQuery: string;\r\n    categoryFilter: string | null;\r\n    onSelectEntry: (id: string) => void;\r\n}\r\n\r\nconst getPreviewText = (content: string) => {\r\n    if (!content) return '';\r\n    // Strip markdown links and image tags, keeping the display text\r\n    let text = content.replace(/!?\\[(.*?)\\]\\(.*?\\)/g, '$1');\r\n    // Remove basic markdown syntax (headings, bold, italic, lists, quotes, code)\r\n    text = text.replace(/[#*`~>-]/g, '');\r\n    // Normalize line breaks and multiple spaces to a single space\r\n    text = text.replace(/\\s+/g, ' ').trim();\r\n    return text.length > 150 ? text.substring(0, 150) + '...' : text;\r\n};\r\n\r\nconst EntryList: React.FC<EntryListProps> = ({ searchQuery, categoryFilter, onSelectEntry }) => {\r\n    const entries = useLiveQuery(\r\n        () => {\r\n            // Fetch all entries then sort by updatedAt desc in JS\r\n            return db.entries.toArray().then(arr =>\r\n                arr.sort((a, b) => b.updatedAt - a.updatedAt)\r\n            );\r\n        },\r\n        []\r\n    ) || [];\r\n\r\n    const filteredEntries = useMemo(() => {\r\n        return entries.filter(entry => {\r\n            // Category filter\r\n            if (categoryFilter && entry.category !== categoryFilter) return false;\r\n\r\n            // Search query filter (title, content, tags)\r\n            if (searchQuery) {\r\n                const q = searchQuery.toLowerCase();\r\n                const inTitle = entry.title.toLowerCase().includes(q);\r\n                const inContent = entry.content.toLowerCase().includes(q);\r\n                const inTags = entry.tags.some(t => t.toLowerCase().includes(q));\r\n                if (!inTitle && !inContent && !inTags) return false;\r\n            }\r\n\r\n            return true;\r\n        });\r\n    }, [entries, categoryFilter, searchQuery]);\r\n\r\n    return (\r\n        <div className={styles.container}>\r\n            <h1 className={styles.title}>{categoryFilter || 'すべてのエントリ'}</h1>\r\n\r\n            {filteredEntries.length === 0 ? (\r\n                <div className={styles.empty}>\r\n                    <FileText size={48} className={styles.emptyIcon} />\r\n                    <p>エントリが見つかりません</p>\r\n                    {!searchQuery && <p className={styles.emptySub}>左下の「新規作成」から追加してください</p>}\r\n                </div>\r\n            ) : (\r\n                <div className={styles.list}>\r\n                    {filteredEntries.map(entry => (\r\n                        <div key={entry.id} className={styles.card} onClick={() => onSelectEntry(entry.id)}>\r\n                            <div className={styles.cardHeader}>\r\n                                <FileText size={18} className={styles.cardIcon} />\r\n                                <h3 className={styles.cardTitle}>{entry.title}</h3>\r\n                            </div>\r\n                            <div className={styles.cardPreview}>\r\n                                {getPreviewText(entry.content)}\r\n                            </div>\r\n                            <div className={styles.cardMeta}>\r\n                                <span className={styles.badge}>{entry.category}</span>\r\n                                <span className={styles.date}>{format(entry.updatedAt, 'yy/MM/dd HH:mm')}</span>\r\n                            </div>\r\n                        </div>\r\n                    ))}\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default EntryList;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\riote\\WorkSpace\\shadow_dex\\src\\components\\HelpModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\riote\\WorkSpace\\shadow_dex\\src\\components\\Layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\riote\\WorkSpace\\shadow_dex\\src\\components\\SearchBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\riote\\WorkSpace\\shadow_dex\\src\\components\\SettingsModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\riote\\WorkSpace\\shadow_dex\\src\\components\\Sidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\riote\\WorkSpace\\shadow_dex\\src\\components\\SyncModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\riote\\WorkSpace\\shadow_dex\\src\\db\\db.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\riote\\WorkSpace\\shadow_dex\\src\\main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\riote\\WorkSpace\\shadow_dex\\src\\sync\\syncManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\riote\\WorkSpace\\shadow_dex\\src\\vite-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\riote\\WorkSpace\\shadow_dex\\vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
